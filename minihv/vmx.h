#ifndef _VMX_H
#define _VMX_H

#include "minihv.h"
#include "cpu.h"
#include "idt.h"
#include "cconsole.h"

// Pack the structures without padding alignment
#pragma pack(push, 1)

// control bits
#define VMCS_ACTIVATE_VMX_PREEMPTION_TIMER_INDEX 6
#define VMCS_HOST_ADDRESS_SPACE_SIZE_BIT_INDEX 9
#define VMCS_SAVE_IA32_EFER_BIT_INDEX 20
#define VMCS_LOAD_IA32_EFER_BIT_INDEX 21
#define VMCS_ACTIVATE_SECONDARY_CONTROLS_BIT_INDEX 31
#define VMCS_USE_IO_BITMAPS_BIT_INDEX 25
#define VMCS_CR3_LOAD_EXITING_BIT_INDEX 15
#define VMCS_CR3_STORE_EXITING_BIT_INDEX 16
#define VMCS_CR8_LOAD_EXITING_BIT_INDEX 19
#define VMCS_CR8_STORE_EXITING_BIT_INDEX 20
#define VMCS_ENABLE_EPT_BIT_INDEX 1
#define VMCS_ENABLE_RDTSCP_BIT_INDEX 3
#define VMCS_ENABLE_INVPCID_BIT_INDEX 12
#define VMCS_ENABLE_XSAVES_XRSTORS_BIT_INDEX 20
#define VMCS_UNRESTRICTED_GUEST_BIT_INDEX 7
#define VMX_LOAD_DEBUG_CONTROLS_BIT_INDEX 2
#define VMX_ENTRY_LOAD_IA32_EFER_BIT_INDEX 15
#define VMX_PRIMARY_PROCESSOR_BASED_CONTROLS_HLT_EXITING_BIT_INDEX 7
#define VMCS_USE_MSR_BITMAPS_BIT_INDEX 28
#define VMCS_IA32E_MODE_GUEST_BIT_INDEX 9
#define VMCS_SELECTOR_ACCESS_RIGHTS_DB_BIT_INDEX 14

// 16 bit fields

// 16 bit control fields
#define VMCS_VPID_ENCODING 0x0
#define VMCS_POSTED_INTERRUPT_NOTIFICATION_VECTOR_ENCODING 0x2
#define VMCS_EPTP_INDEX_ENCODING 0x4

// 16 bit guest state fields
#define VMCS_GUEST_ES_ENCODING 0x800
#define VMCS_GUEST_CS_ENCODING 0x802
#define VMCS_GUEST_SS_ENCODING 0x804
#define VMCS_GUEST_DS_ENCODING 0x806
#define VMCS_GUEST_FS_ENCODING 0x808
#define VMCS_GUEST_GS_ENCODING 0x80A
#define VMCS_GUEST_LDTR_ENCODING 0x80C
#define VMCS_GUEST_TR_ENCODING 0x80E
#define VMCS_GUEST_INTERRUPT_STATUS_ENCODING 0x810
#define VMCS_GUEST_PML_ENCODING 0x812

// 16 bit host state fields
#define VMCS_HOST_ES_ENCODING 0xC00
#define VMCS_HOST_CS_ENCODING 0xC02
#define VMCS_HOST_SS_ENCODING 0xC04
#define VMCS_HOST_DS_ENCODING 0xC06
#define VMCS_HOST_FS_ENCODING 0xC08
#define VMCS_HOST_GS_ENCODING 0xC0A
#define VMCS_HOST_TR_ENCODING 0xC0C

// 64 bit fields

// 64-Bit Control Fields
#define VMCS_ADDRESS_OF_IO_BITMAP_A_FULL_ENCODING 0x00002000
#define VMCS_ADDRESS_OF_IO_BITMAP_B_FULL_ENCODING 0x00002002
#define VMCS_ADDRESS_OF_MSR_BITMAPS_FULL_ENCODING 0x00002004
#define VMCS_VM_EXIT_MSR_STORE_ADDRESS_FULL_ENCODING 0x00002006
#define VMCS_VM_EXIT_MSR_LOAD_ADDRESS_FULL_ENCODING 0x00002008
#define VMCS_VM_ENTRY_MSR_LOAD_ADDRESS_FULL_ENCODING 0x0000200A
#define VMCS_EXECUTIVE_VMCS_POINTER_FULL_ENCODING 0x0000200C
#define VMCS_PML_ADDRESS_FULL_ENCODING 0x0000200E
#define VMCS_TSC_OFFSET_FULL_ENCODING 0x00002010
#define VMCS_VIRTUAL_APIC_ADDRESS_FULL_ENCODING 0x00002012
#define VMCS_APIC_ACCESS_ADDRESS_FULL_ENCODING 0x00002014
#define VMCS_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS_FULL_ENCODING 0x00002016
#define VMCS_VM_FUNCTION_CONTROLS_FULL_ENCODING 0x00002018
#define VMCS_EPT_POINTER_FULL_ENCODING 0x0000201A
#define VMCS_EOI_EXIT_BITMAP_0_FULL_ENCODING 0x0000201C
#define VMCS_EOI_EXIT_BITMAP_1_FULL_ENCODING 0x0000201E
#define VMCS_EOI_EXIT_BITMAP_2_FULL_ENCODING 0x00002020
#define VMCS_EOI_EXIT_BITMAP_3_FULL_ENCODING 0x00002022
#define VMCS_EPTP_LIST_ADDRESS_FULL_ENCODING 0x00002024
#define VMCS_VMREAD_BITMAP_ADDRESS_FULL_ENCODING 0x00002026
#define VMCS_VMWRITE_BITMAP_ADDRESS_FULL_ENCODING 0x00002028
#define VMCS_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS_FULL_ENCODING 0x0000202A
#define VMCS_XSS_EXITING_BITMAP_FULL_ENCODING 0x0000202C
#define VMCS_ENCLS_EXITING_BITMAP_FULL_ENCODING 0x0000202E
#define VMCS_TSC_MULTIPLIER_FULL_ENCODING 0x00002032

// 64-Bit Read-Only Data Field

#define VMCS_GUEST_PHYSICAL_ADDRESS_FULL_ENCODING 0x00002400

// 64-Bit Guest-State Fields

#define VMCS_LINK_POINTER_FULL_ENCODING 0x00002800
#define VMCS_GUEST_IA32_DEBUGCTL_FULL_ENCODING 0x00002802
#define VMCS_GUEST_IA32_PAT_FULL_ENCODING 0x00002804
#define VMCS_GUEST_IA32_EFER_FULL_ENCODING 0x00002806
#define VMCS_GUEST_IA32_PERF_GLOBAL_CTRL_FULL_ENCODING 0x00002808
#define VMCS_GUEST_PDEPT0_FULL_ENCODING 0x0000280A
#define VMCS_GUEST_PDEPT1_FULL_ENCODING 0x0000280C
#define VMCS_GUEST_PDEPT2_FULL_ENCODING 0x0000280E
#define VMCS_GUEST_PDEPT3_FULL_ENCODING 0x00002810
#define VMCS_GUEST_IA32_BNDCFGS_FULL_ENCODING 0x00002812

// 64-Bit Host-State Fields
#define VMCS_HOST_IA32_PAT_FULL_ENCODING 0x00002C00
#define VMCS_HOST_IA32_EFER_FULL_ENCODING 0x00002C02
#define VMCS_HOST_IA32_BNDCFGS_FULL_ENCODING 0x00002C04

// 32 bit fields

// 32 bit Control fields
#define VMCS_PIN_BASED_VM_EXECUTION_CONTROL_ENCODING 0x00004000
#define VMCS_PRIMARY_PROCESSOR_VM_EXECUTION_CONTROL_ENCODING 0x00004002
#define VMCS_EXCEPTION_BITMAP_ENCODING 0x00004004
#define VMCS_PAGE_FAULT_ERROR_CODE_MASK_ENCODING 0x00004006
#define VMCS_PAGE_FAULT_ERROR_CODE_MATCH_ENCODING 0x00004008
#define VMCS_CR3_TARGET_COUNT_ENCODING 0x0000400A
#define VMCS_VM_EXIT_CONTROLS_ENCODING 0x0000400C
#define VMCS_VM_EXIT_MSR_STORE_COUNT_ENCODING 0x0000400E
#define VMCS_VM_EXIT_MSR_LOAD_COUNT_ENCODING 0x00004010
#define VMCS_VM_ENTRY_CONTROLS_ENCODING 0x00004012
#define VMCS_VM_ENTRY_MSR_LOAD_COUNT_ENCODING 0x00004014
#define VMCS_VM_ENTRY_INTERRUPTION_INFORMATION_FIELD_ENCODING 0x00004016
#define VMCS_VM_ENTRY_EXCEPTION_ERROR_CODE_ENCODING 0x00004018
#define VMCS_VM_ENTRY_INSTRUCTION_LENGTH_ENCODING 0x0000401A
#define VMCS_SECONDARY_PROCESSOR_VM_EXECUTION_CONTROL_ENCODING 0x0000401E
#define VMCS_PLE_GAP_ENCODING 0x00004020
#define VMCS_PLE_WINDOW_ENCODING 0x00004022

// 32 - Bit Read - Only Data Fields
#define VMCS_VM_INSTRUCTION_ERROR_ENCODING   0x00004400
#define VMCS_EXIT_REASON_ENCODING            0x00004402
#define VMCS_VM_EXIT_INTERRUPTION_INFORMATION_ENCODING 0x00004404
#define VMCS_VM_EXIT_INTERRUPTION_ERROR_CODE_ENCODING 0x00004406
#define VMCS_IDT_VECTORING_INFORMATION_FIELD_ENCODING 0x00004408
#define VMCS_IDT_VECTORING_ERROR_CODE_ENCODING 0x0000440A
#define VMCS_VM_EXIT_INSTRUCTION_LENGTH_ENCODING 0x0000440C
#define VMCS_VM_EXIT_INSTRUCTION_INFORMATION_ENCODING 0x0000440E

// 32-Bit Guest-State Fields
#define VMCS_GUEST_ES_LIMIT_ENCODING 0x00004800
#define VMCS_GUEST_CS_LIMIT_ENCODING 0x00004802
#define VMCS_GUEST_SS_LIMIT_ENCODING 0x00004804
#define VMCS_GUEST_DS_LIMIT_ENCODING 0x00004806
#define VMCS_GUEST_FS_LIMIT_ENCODING 0x00004808
#define VMCS_GUEST_GS_LIMIT_ENCODING 0x0000480A
#define VMCS_GUEST_LDTR_LIMIT_ENCODING 0x0000480C
#define VMCS_GUEST_TR_LIMIT_ENCODING 0x0000480E
#define VMCS_GUEST_GDTR_LIMIT_ENCODING 0x00004810
#define VMCS_GUEST_IDTR_LIMIT_ENCODING 0x00004812
#define VMCS_GUEST_ES_ACCESS_RIGHTS_ENCODING 0x00004814
#define VMCS_GUEST_CS_ACCESS_RIGHTS_ENCODING 0x00004816
#define VMCS_GUEST_SS_ACCESS_RIGHTS_ENCODING 0x00004818
#define VMCS_GUEST_DS_ACCESS_RIGHTS_ENCODING 0x0000481A
#define VMCS_GUEST_FS_ACCESS_RIGHTS_ENCODING 0x0000481C
#define VMCS_GUEST_GS_ACCESS_RIGHTS_ENCODING 0x0000481E
#define VMCS_GUEST_LDTR_ACCESS_RIGHTS_ENCODING 0x00004820
#define VMCS_GUEST_TR_ACCESS_RIGHTS_ENCODING 0x00004822
#define VMCS_GUEST_INTERRUPTIBILITY_STATE_ENCODING 0x00004824
#define VMCS_GUEST_ACTIVITY_STATE_ENCODING 0x00004826
#define VMCS_GUEST_SMBASE_ENCODING 0x00004828
#define VMCS_GUEST_IA32_SYSENTER_CS_ENCODING 0x0000482A
#define VMCS_GUEST_VMX_PREEMPTION_TIMER_ENCODING 0x0000482E

// 32-Bit Host-State Field

#define VMCS_HOST_IA32_SYSENTER_CS_ENCODING 0x00004C00

// Natural-Width Control Fields

#define VMCS_CR0_GUEST_HOST_MASK_ENCODING 0x00006000
#define VMCS_CR4_GUEST_HOST_MASK_ENCODING 0x00006002
#define VMCS_CR0_READ_SHADOW_ENCODING 0x00006004
#define VMCS_CR4_READ_SHADOW_ENCODING 0x00006006
#define VMCS_CR3_TARGET_VALUE_0_ENCODING 0x00006008
#define VMCS_CR3_TARGET_VALUE_1_ENCODING 0x0000600A
#define VMCS_CR3_TARGET_VALUE_2_ENCODING 0x0000600C
#define VMCS_CR3_TARGET_VALUE_3_ENCODING 0x0000600E

// Natural-Width Read-Only Data Fields

#define VMCS_EXIT_QUALIFICATION_ENCODING 0x00006400
#define VMCS_IO_RCX_ENCODING 0x00006402
#define VMCS_IO_RSI_ENCODING 0x00006404
#define VMCS_IO_RDI_ENCODING 0x00006406
#define VMCS_IO_RIP_ENCODING 0x00006408
#define VMCS_GUEST_LINIAR_ADDRESS_ENCODING 0x0000640A

// Natural-Width Guest-State Fields

#define VMCS_GUEST_CR0_ENCODING 0x00006800
#define VMCS_GUEST_CR3_ENCODING 0x00006802
#define VMCS_GUEST_CR4_ENCODING 0x00006804
#define VMCS_GUEST_ES_BASE_ENCODING 0x00006806
#define VMCS_GUEST_CS_BASE_ENCODING 0x00006808
#define VMCS_GUEST_SS_BASE_ENCODING 0x0000680A
#define VMCS_GUEST_DS_BASE_ENCODING 0x0000680C
#define VMCS_GUEST_FS_BASE_ENCODING 0x0000680E
#define VMCS_GUEST_GS_BASE_ENCODING 0x00006810
#define VMCS_GUEST_LDTR_BASE_ENCODING 0x00006812
#define VMCS_GUEST_TR_BASE_ENCODING 0x00006814
#define VMCS_GUEST_GDTR_BASE_ENCODING 0x00006816
#define VMCS_GUEST_IDTR_BASE_ENCODING 0x00006818
#define VMCS_GUEST_DR7_ENCODING 0x0000681A
#define VMCS_GUEST_RSP_ENCODING 0x0000681C
#define VMCS_GUEST_RIP_ENCODING 0x0000681E
#define VMCS_GUEST_RFLAGS_ENCODING 0x00006820
#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS_ENCODING 0x00006822
#define VMCS_GUEST_IA32_SYSENTER_ESP_ENCODING 0x00006824
#define VMCS_GUEST_IA32_SYSENTER_EIP_ENCODING 0x00006826

// Natural-Width Host-State Fields
#define VMCS_HOST_CR0_ENCODING 0x00006C00
#define VMCS_HOST_CR3_ENCODING 0x00006C02
#define VMCS_HOST_CR4_ENCODING 0x00006C04
#define VMCS_HOST_FS_BASE_ENCODING 0x00006C06
#define VMCS_HOST_GS_BASE_ENCODING 0x00006C08
#define VMCS_HOST_TR_BASE_ENCODING 0x00006C0A
#define VMCS_HOST_GDTR_BASE_ENCODING 0x00006C0C
#define VMCS_HOST_IDTR_BASE_ENCODING 0x00006C0E
#define VMCS_HOST_IA32_SYSENTER_ESP_ENCODING 0x00006C10
#define VMCS_HOST_IA32_SYSENTER_EIP_ENCODING 0x00006C12
#define VMCS_HOST_RSP_ENCODING 0x00006C14
#define VMCS_HOST_RIP_ENCODING 0x00006C16

#define VMCS_INVALID_VMCS_LINK_POINTER MAX_QWORD

#define VMX_BASIC_EXIT_REASON_MASK 0xFFFF
#define VMX_BASIC_EXIT_REASON_PREEMPTION_TIMER_EXPIRED 0x34
#define VMX_BASIC_EXIT_REASON_TASK_SWITCH 0x9
#define VMX_BASIC_EXIT_REASON_CPUID 0xA
#define VMX_BASIC_EXIT_REASON_RDMSR 0x1F
#define VMX_BASIC_EXIT_REASON_WRMSR 0x20
#define VMX_BASIC_EXIT_REASON_XSETBV 0x37
#define VMX_BASIC_EXIT_REASON_INIT_SIGNAL 0x3
#define VMX_BASIC_EXIT_REASON_SIPI_SIGNAL 0x4
#define VMX_BASIC_EXIT_REASON_VMCALL 0x12
#define VMX_BASIC_EXIT_REASON_IO_INSTRUCTION 0x1E
#define VMX_BASIC_EXIT_REASON_EPT_VIOLATION 0x30
#define VMX_BASIC_EXIT_REASON_EPT_VIOLATION_SEC 0x33

#define VMX_SEGMEMT_REGISTERS_ACCESS_RIGHTS_TYPE_MASK(x) ((x) << 0)
#define VMX_SEGMEMT_REGISTERS_ACCESS_RIGHTS_S_BIT_INDEX (4)
#define VMX_SEGMEMT_REGISTERS_ACCESS_RIGHTS_P_BIT_INDEX (7)
#define VMX_SEGMEMT_REGISTERS_ACCESS_RIGHTS_G_BIT_INDEX (15)
#define VMX_SEGMEMT_REGISTERS_ACCESS_RIGHTS_UNUSABLE_BIT_INDEX (16)

#define VMX_MSR_BITMAP_SIZE 1024
#define VMX_MSR_BITMAPS_SIZE 4 * VMX_MSR_BITMAP_SIZE

#define VMX_IO_BITMAP_SIZE 0x1000

#define VMCS_PREEMPTION_TIMER_DUMMY_VALUE 100000000

#define CPUID_RAX 0x00
#define CPUID_RBX 0x01
#define CPUID_RCX 0x02
#define CPUID_RDX 0x03

#define CPUID_01H_RCX_XSAVE_BIT_INDEX   0x1A
#define CPUID_01H_RCX_OSXSAVE_BIT_INDEX 0x1B

#define CR4_VMXE_BIT_INDEX 13
#define CR4_OSXSAVE_BIT_INDEX 18

#define SOURCE_OF_TASK_INIT 0x03

#define SET_BITT(x, b) (x |= (1ULL << b))
#define CLEAR_BITT(x, b) (x &= (~(1 << b)))

#define PCI_CONFIG_ADDRESS_PORT 0xCF8
#define PCI_CONFIG_DATA_PORT 0xCFC

#define INVALID_VENDOR_ID 0xFFFF

#define PCI_CONFIG_ADDRESS_FUNCTION_SHIFT 0x08
#define PCI_CONFIG_ADDRESS_DEVICE_SHIFT 0x0B
#define PCI_CONFIG_ADDRESS_BUS_SHIFT 0x10

#define PCI_CONFIG_ADDRESS_FUNCTION_MASK 0x7
#define PCI_CONFIG_ADDRESS_DEVICE_MASK 0x1F
#define PCI_CONFIG_ADDRESS_BUS_MASK 0xFF

#define MHV_SIGN                            'wtfd'
#define HYPER_V_BIT                         0x80000000
#define HYPER_V_INT                         0x40000001

//BOOLEAN gPutBreak = FALSE;

static QWORD gVal = 0;

#define VMX_WRITE   0x00000000
#define VMX_READ    0x00000001

#define VMX_SHORT_LOG(ENCODING, VALUE, OP)                                               \
{                                                                                        \
    do                                                                                   \
    {       SetNewLine(FALSE);                                                           \
            if (OP == VMX_WRITE)                                                         \
            {                                                                            \
                LOG("Write %s: value: 0x%X", ENCODING, VALUE);                           \
            }                                                                            \
            else if (OP == VMX_READ)                                                     \
            {                                                                            \
                LOG("Read value from: %s, in variabile: %s" ENCODING, VALUE);            \
            }                                                                            \
            SetNewLine(TRUE);                                                            \
    } while (0);                                                                         \
}

static
VOID
SetGlobalVal(
    QWORD Val
)
{
    gVal = Val;
}

typedef enum _MSR_BITS
{
    MSR_IA31_FEATURE_CONTROL_LOCK_BIT,               //
    MSR_IA31_FEATURE_CONTROL_VMXON_IN_SMX,           //
    MSR_IA31_FEATURE_CONTROL_VMXON_OUTSIDE_SMD       //
}MSR_BITS;

typedef enum _VMX_STATUS
{
    VMX_Success,
    VMX_FailureWithErrorCode,
    VMX_FailureWithoutErrorCode
}VMX_STATUS /* *PVMX_STATUS  (USELESS)*/;


typedef enum _EXT_SOURCE_TASK_SWITCH
{
    BIT_CALL_INSTR,
    BIT_IRET_INSTR,
    BIT_JMP_INSTR,
    BIT_TASK_GATE_IDT
}EXT_SOURCE_TASK_SWITCH;

typedef struct _VMCS_REVISION_IDENTIFIER
{
    DWORD VMCS_REVISION_IDENT : 30;
    DWORD VMCS_SHADOW_INDICATOR : 1;
}VMCS_REVISION_IDENTIFIER, *PVMCS_REVISION_IDENTIFIER;

typedef struct _FORMAT_ACCESS_RIGHTS
{
    // Format access rights -> 24.4.1 Guest Register State
    DWORD SegmType : 4;
    DWORD S : 1;
    DWORD Dpl : 2;
    DWORD P : 1;
    DWORD Resv1 : 4;
    DWORD Avl : 1;
    DWORD Resv2 : 1;
    DWORD D_B : 1;
    DWORD G : 1;
    DWORD Segm_unusable : 1;
    DWORD Resv3 : 15;
}FORMAT_ACCESS_RGIHTS, *PFORMAT_ACCESS_RIGHTS;


#pragma warning(disable:4201)
typedef union _VM_ENTRY_INTERRUPTION_INFORMATION_FIELD
{
    struct
    {
        DWORD Vector : 8;
        DWORD InterruptionType : 3;
        DWORD DeliverErrorCode : 1;
        DWORD Reserved : 19;
        DWORD Valid : 1;
    };

    DWORD Raw;
} VM_ENTRY_INTERRUPTION_INFORMATION_FIELD, *PVM_ENTRY_INTERRUPTION_INFORMATION_FIELD;

typedef struct _SEGMENT_REGISTERS
{
    WORD                    Selector;
    QWORD                   BaseAdress;
    DWORD                   SegmentLimit;
    FORMAT_ACCESS_RGIHTS    AccessRights;
}SEGMENT_REGISTER, *PSEGMENT_REGISTER;

typedef struct _GUEST_REGISTER_STATE
{
    // Control register; 64 bits each | Processor supports Intel 64 architecture
    QWORD CR0;
    QWORD CR3;
    QWORD CR4;

    // Debug register; 64 bits | Processor supports Intel 64 architecture
    QWORD DR7;

    // Processor registers; 64 bits each | Processor supports Intel 64 architecture
    QWORD RSP;      // 64 bits Sack Pointer
    QWORD RIP;      // 64 bits Instruction Pointer
    QWORD RFLAGS;   // CF, PF, AF, ZF, SF .... .... ....

                    // Specific fields for following segm. registers
    SEGMENT_REGISTER CS;
    SEGMENT_REGISTER SS;
    SEGMENT_REGISTER DS;
    SEGMENT_REGISTER ES;
    SEGMENT_REGISTER FS;
    SEGMENT_REGISTER GS;
    SEGMENT_REGISTER LDTR;
    SEGMENT_REGISTER TR;
}GUEST_REGISTER_STATE, *PGUEST_REGISTER_STATE;

typedef struct _VMCS
{
    VMCS_REVISION_IDENTIFIER RevIdent;

}VMCS, *PVMCS;

typedef struct _VCPU
{
    PVMCS Vmcs;
    PVOID VmcsPa;
} VCPU, *PVCPU;


typedef union _EPTP
{
    struct
    {
        QWORD MemoryType : 3;
        QWORD PgWalkLenMinusOne : 3;
        QWORD EnableAccessedAndDirtyBit : 1;
        QWORD Reserved : 5;
        QWORD PhysicalAddress : 52;
    };

    QWORD Raw;
} EPTP, *PEPTP;

#pragma pack(pop)



typedef enum _ACTIVITY_STATE
{
    Active,
    HLT,
    Shutdown,
    WaitForSipi
}ACTIVITY_STATE;


NTSTATUS
CheckVmxSupported(
    VOID
);

NTSTATUS
VmxInit(
    _In_ PCPU cpu
);

VOID
VmxVmExitHandler(
    PPROCESSOR_STATE ProcessorState
);

//VOID
//SetBreak(
//    BOOLEAN Opt
//);

NTSTATUS pVmxLaunch(VOID);

VOID
VmxConfigureGuestCode(
    VOID
);


PVOID
VmxGetPml4Pa(
    VOID
);

QWORD
ReadMsr(
    _In_ DWORD Address,
    _In_ QWORD Bit,
    _In_ QWORD Mask
);

VOID
VmxPatchRealModeInt15hE820(
    VOID
);

VOID
VmxJumpToNextInstr(
    VOID
);

NTSTATUS
VmxRead(
    char *EncodingName,
    QWORD Encoding,
    PVOID Destination
);

NTSTATUS
VmxOff(
    VOID
);


VOID
VmxSetBitInBitmap(
    PBYTE Bitmap,
    WORD BitIndex,
    BOOLEAN SetBit
);

NTSTATUS
VmxStatusToNtStatus(
    VMX_STATUS VmxStatus
);

NTSTATUS VmxBasicExitReasonPreemptionTimerExpired(_In_ PPROCESSOR_STATE ProcessorState);
NTSTATUS VmxBasicExitReasonTaskSwitch(_In_ PPROCESSOR_STATE ProcessorState);
NTSTATUS VmxBasicExitReasonIoInstruction(_In_ PPROCESSOR_STATE ProcessorState);
NTSTATUS VmxBasicExitReasonCpuid(_In_ PPROCESSOR_STATE ProcessorState);
NTSTATUS VmxBasicExitReasonEptViolation(_In_ PPROCESSOR_STATE ProcessorState);
NTSTATUS VmxBasicExitReasonVmcall(_In_ PPROCESSOR_STATE ProcessorState);
NTSTATUS VmxBasicExitReasonXsetbv(_In_ PPROCESSOR_STATE ProcessorState);
NTSTATUS VmxBasicExitReasonRdmsr(_In_ PPROCESSOR_STATE ProcessorState);


#endif // _VMX_H
